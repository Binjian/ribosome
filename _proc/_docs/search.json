[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{{ribosome}}",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "{{ribosome}}"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "{{ribosome}}",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using ribosome here are some useful pointers to get you started.\n\nInstall ribosome in Development mode\n# make sure ribosome package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to ribosome\n$ nbdev_prepare",
    "crumbs": [
      "{{ribosome}}"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "{{ribosome}}",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/Binjian/ribosome.git\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "{{ribosome}}"
    ]
  },
  {
    "objectID": "index.html#document-object-model",
    "href": "index.html#document-object-model",
    "title": "{{ribosome}}",
    "section": "Document Object Model",
    "text": "Document Object Model\nThe ribosome package provides a Document Object Model (DOM) for working with Markdown documents. The DOM allows you to manipulate the structure and content of Markdown files programmatically.\n\n\n\n\n\n---\nconfig:\n  theme: 'forest'\n  themeVariables:\n    primaryColor: '#BB2528'\n    primaryTextColor: '#fff'\n    primaryBorderColor: '#7C0000'\n    lineColor: '#F8B229'\n    secondaryColor: '#006100'\n    tertiaryColor: '#fff'\n---\n\nclassDiagram\nclass Element{\n    string summary\n}\nclass Figure~Element~{\n    base64 rawdata\n}\nstyle Element fill:lime\nstyle Figure fill:lightblue\nElement &lt;|-- Figure\nclass Cell {\n    string c\n}\nclass Column {\n    List~Cell~ cells\n}\nclass Row {\n    List~Column~ cols\n}\nclass Table~Element~ {\n    List~Row~ rows\n}\nCell *-- Column\nColumn *-- Row\nRow *-- Table\nElement &lt;|-- Table\nstyle Table fill:lightblue\n\n\nclass Paragraph~Element~{\n    string text\n}\nstyle Paragraph fill:lightblue\nElement &lt;|-- Paragraph\n\nclass Markdown\nstyle Markdown fill:yellow\n\nclass Section~Element~{\n    +string summary\n    +string title\n    +List~Paragraph~ paragraphs\n    +List~Figure~ figures\n    +List~Table~ tables\n    +List~Section~ subsections\n    +init(Markdown md)\n}\nstyle Section fill:fuchsia\n\nTable *-- Section \nFigure *-- Section \nSection *-- Section",
    "crumbs": [
      "{{ribosome}}"
    ]
  },
  {
    "objectID": "index.html#file-system-embedding",
    "href": "index.html#file-system-embedding",
    "title": "{{ribosome}}",
    "section": "File system embedding",
    "text": "File system embedding\nThe ribosome package provides a file system embedding feature that allows you to work with Markdown files directly from the file system. This feature is useful for managing and organizing your Markdown documents.\n\n\n\n\n\n---\nconfig:\n  theme: 'forest'\n  themeVariables:\n    primaryColor: '#BB2528'\n    primaryTextColor: '#fff'\n    primaryBorderColor: '#7C0000'\n    lineColor: '#F8B229'\n    secondaryColor: '#006100'\n    tertiaryColor: '#fff'\n---\n\nclassDiagram\nclass Element{\n    string summary\n}\nstyle Element fill:lime\nclass File{\n    +string title\n    +Path path\n    +List~Section~ sections\n}\nElement &lt;|-- File\nElement &lt;|-- Section\nSection *-- File\n\n\nclass Folder{\n    +string title\n    +Path path\n    +List~File~ files\n    +List~Folder~ subfolders\n    +init(Markdown md)\n}\nElement &lt;|-- Folder\nFile *-- Folder\nFolder *-- Folder\nstyle Folder fill:fuchsia",
    "crumbs": [
      "{{ribosome}}"
    ]
  },
  {
    "objectID": "index.html#semantical-tree-with-embedding-vector-space",
    "href": "index.html#semantical-tree-with-embedding-vector-space",
    "title": "{{ribosome}}",
    "section": "Semantical tree with embedding vector space",
    "text": "Semantical tree with embedding vector space\n\n\n\n\n\n---\nconfig:\n  theme: 'forest'\n  themeVariables:\n    primaryColor: '#BB2528'\n    primaryTextColor: '#fff'\n    primaryBorderColor: '#7C0000'\n    lineColor: '#F8B229'\n    secondaryColor: '#006100'\n    tertiaryColor: '#fff'\n---\n\ngraph LR;\n    subgraph 计算语义\n                text(文本) --&gt; 内嵌\n    end\n        内嵌 --&gt; 语义树\n    subgraph 检索\n        语义树 --&gt; 摘要 --&gt; 对象树\n        end\n\n        text --&gt; raw[(原始文件)]\n        语义树 --&gt; embedding[(向量数据库)]\n        对象树 --&gt; markdown[(内容对象数据库)]",
    "crumbs": [
      "{{ribosome}}"
    ]
  },
  {
    "objectID": "03.chroma_db.html#make-an-app-with-gradio",
    "href": "03.chroma_db.html#make-an-app-with-gradio",
    "title": "chroma_db",
    "section": "Make an app with Gradio",
    "text": "Make an app with Gradio\nThis is a simple RAG chatbot built on top of Llama Index and Gradio. It allows you to upload any text or PDF files and ask questions about them! Before running this, make sure you have exported your OpenAI API key as an environment variable:\nexport OPENAI_API_KEY=\"mykey\"\n\noai_key = os.getenv(\"GEMINI_API_KEY\")\nprint(oai_key)\n\n\nhttp_proxy = os.getenv(\"HTTP_PROXY\")\nhttps_proxy = os.getenv(\"HTTPS_PROXY\")\nprint(http_proxy, https_proxy)\n\n# os.environ[\"HTTP_PROXY\"] = ''\n# os.environ[\"HTTPS_PROXY\"] = ''\n# http_proxy = os.getenv(\"HTTP_PROXY\")\n# https_proxy = os.getenv(\"HTTPS_PROXY\")\n# print(http_proxy, https_proxy)\n\n\nresults['documents'][0][0] if results['documents'] else None\nresults['ids'][0][0] if results['ids'] else None\nresults['metadatas'][0][0] if results['metadatas'] else None\n\n\nresults['documents'][0][1] if results['documents'] else None\nresults['ids'][0][1] if results['ids'] else None\nresults['metadatas'][0][1] if results['metadatas'] else None",
    "crumbs": [
      "chroma_db"
    ]
  },
  {
    "objectID": "01.core.dom.html",
    "href": "01.core.dom.html",
    "title": "core.dom",
    "section": "",
    "text": "Element (summary:Optional[str]=None)\n\nRepresents a DOM element with a tag, attributes, and children.",
    "crumbs": [
      "core.dom"
    ]
  },
  {
    "objectID": "01.core.dom.html#base-element-class",
    "href": "01.core.dom.html#base-element-class",
    "title": "core.dom",
    "section": "",
    "text": "Element (summary:Optional[str]=None)\n\nRepresents a DOM element with a tag, attributes, and children.",
    "crumbs": [
      "core.dom"
    ]
  },
  {
    "objectID": "01.core.dom.html#figure-class-with-base64-validation",
    "href": "01.core.dom.html#figure-class-with-base64-validation",
    "title": "core.dom",
    "section": "Figure Class with Base64 Validation",
    "text": "Figure Class with Base64 Validation\n\n\nFigure\n\n Figure (summary:Optional[str]=None, rawdata:str)\n\nRepresents a figure element in the document.",
    "crumbs": [
      "core.dom"
    ]
  },
  {
    "objectID": "01.core.dom.html#table-structure-cell-column-row-table",
    "href": "01.core.dom.html#table-structure-cell-column-row-table",
    "title": "core.dom",
    "section": "Table Structure: Cell, Column, Row, Table",
    "text": "Table Structure: Cell, Column, Row, Table\n\n\nTable\n\n Table (summary:Optional[str]=None, rows:List[__main__.Row])\n\nRepresents a table element in the document.\n\n\n\nRow\n\n Row (cols:List[__main__.Column])\n\nRepresents a table row in the document.\n\n\n\nColumn\n\n Column (cells:List[__main__.Cell])\n\nRepresents a table column in the document.\n\n\n\nCell\n\n Cell (c:str)\n\nRepresents a table cell in the document.\n\n\n\nget_text_summary_response\n\n get_text_summary_response (content:str, model:str='gemma3-27b',\n                            role:str='user', lang:str='zh')\n\nReturns a ChatResponse from the chat model with a summary prompt for the given content.\n\n\n\nget_image_summary_response\n\n get_image_summary_response (image_link:str|pathlib.Path,\n                             model:str='gemma3:27b', role:str='user',\n                             lang:str='zh')\n\nReturns a ChatResponse from the chat model with a summary prompt for the given image.\n\n\n\nget_image_summary_response_async\n\n get_image_summary_response_async (client:ollama._client.AsyncClient,\n                                   image_link:str|pathlib.Path,\n                                   model:str='gemma3:27b',\n                                   role:str='user', lang:str='zh')\n\nReturns a ChatResponse from the chat model with a summary prompt for the given image.\n\n\n\nget_text_summary_response_async\n\n get_text_summary_response_async (client:ollama._client.AsyncClient,\n                                  content:str, model:str='gemma3-27b',\n                                  role:str='user', lang:str='zh')\n\nReturns a ChatResponse from the chat model with a summary prompt for the given content.\n\nimagepath = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SN024002/img/img_13.png'\n# imagepath = Path(os.getcwd()).parent / 'res/siasun_md_sample/SN024002/img/img_13.png'\n# imagepath = Path(os.getcwd()).parent / 'siasun_md_sample_hrsl/SN024002/img/img_11.png'\n# imagepath = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SX322002/img/img_13.png'\nimage_link = str(imagepath)\nimage_link\ndisplay(Markdown(f\"![image]({image_link})\"))\n\n\n# res = re.match(image_link_pattern, 'http://baidu.com/?home/img/small.png')\nres = re.match(image_link_pattern, 'img/small.png')\n# res = re.match(image_link_pattern, image_link)\n# in case of match, print the matched string\nif res:\n    print(f\"Matched image link: {res.group(0)}\")\nelse:\n    print(res)\n\n\nif False: \n    # response = await get_image_summary_response_async(image_link, model=\"gemma3:27b\", role=\"user\", lang='zh')\n    response = await get_image_summary_response_async(chat_client, image_link, model=\"gemma3:27b\", role=\"user\", lang='zh')\n    assert isinstance(response.message.content, str), \"Response content should be a string\"\n    md_text = markdown.markdown(response.message.content)\n    Markdown(md_text)\n    # print(md_text)\n    # print(response.content)\n    # response_txt = await get_text_summary_response_async(md_text,model=\"gemma3:27b\", role=\"user\", lang='zh')\n    # md_text = markdown.markdown(response_txt.message.content)\n    # Markdown(md_text)\n\n\nif False: \n    # response = await get_image_summary_response_async(image_link, model=\"gemma3:27b\", role=\"user\", lang='zh')\n    response = await get_image_summary_response_async(chat_client, image_link, model=\"gemma3:27b\", role=\"user\", lang='zh')\n    assert isinstance(response.message.content, str), \"Response content should be a string\"\n    md_text = markdown.markdown(response.message.content)\n    Markdown(md_text)\n    # print(md_text)\n    # print(response.content)\n    # response_txt = await get_text_summary_response_async(md_text,model=\"gemma3:27b\", role=\"user\", lang='zh')\n    # md_text = markdown.markdown(response_txt.message.content)\n    # Markdown(md_text)",
    "crumbs": [
      "core.dom"
    ]
  },
  {
    "objectID": "01.core.dom.html#dom-class-with-pypandoc-integration",
    "href": "01.core.dom.html#dom-class-with-pypandoc-integration",
    "title": "core.dom",
    "section": "DOM Class with pypandoc Integration",
    "text": "DOM Class with pypandoc Integration\n\n\nDOM\n\n DOM (md_file_path:pathlib.Path,\n      llm_client:Optional[ollama._client.AsyncClient]=None,\n      db_client:Optional[chromadb.api.ClientAPI]=None,\n      raw_markdown:Optional[str]=None, raw_json:Optional[str]=None,\n      ast_json:Optional[str]=None, semantics_json:Optional[str]=None,\n      embed_json:Optional[str]=None,\n      file_path:Optional[pathlib.Path]=None,\n      root_path:pathlib.Path=&lt;factory&gt;, table_count:int=0,\n      section_count:int=0, section_level:list=&lt;factory&gt;, title:str='')\n\n*Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\nA base class for creating Pydantic models.\nAttributes: class_vars: The names of the class variables defined on the model. private_attributes: Metadata about the private attributes of the model. signature: The synthesized __init__ [Signature][inspect.Signature] of the model.\n__pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n__pydantic_core_schema__: The core schema of the model.\n__pydantic_custom_init__: Whether the model has a custom `__init__` function.\n__pydantic_decorators__: Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n__pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n__pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n__pydantic_post_init__: The name of the post-init method for the model, if defined.\n__pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n__pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n__pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n__pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n__pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n__pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n    is set to `'allow'`.\n__pydantic_fields_set__: The names of fields explicitly set during instantiation.\n__pydantic_private__: Values of private attributes set on the model instance.*\n\nif False:\n    # md_file = Path('/d/devel/rag/ribosome/res/md.hrsl/01 设计标准/SX047001新松机器人产品识别设计标准A-1/SX047001新松机器人产品识别设计标准A-1.md') \n    # md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SR02400401/SR02400401《 SIASUN SR210A-210-2.65 Specifications-CE》A-0.md'\n    # md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SX322002/SX322002.md'\n    # md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SR024011/SR024011.md'\n    md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SN024002/SN024002.md'\n    # md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample/SN024002/SN024002.md'\n    print(f\"Using file: {md_file}\")\n    print(f\"File exists: {md_file.exists()}\")\n    \n    if md_file.exists():\n        dom = DOM(md_file, client=chat_client)\n        dom.setup()\n        print(f\"Raw JSON length: {len(dom.raw_json) if dom.raw_json else 0}\")\n        print(f\"AST JSON length: {len(dom.ast_json) if dom.ast_json else 0}\")\n        \n        js_sections_file = md_file.parent / (str(md_file.stem) + \"_presentation.json\")\n        print(f\"Saving to: {js_sections_file}\")\n        # Write the JSON representation of the AST to the file\n        js_sections_file.write_text(dom.ast_json, encoding=\"utf-8\")\n        \n        # Test textualize functionality\n        print(\"Starting textualization...\")\n        await dom.textualize()\n        \n        js_semantics_file = md_file.parent / (str(md_file.stem) + \"_semantics.json\")\n        js_semantics_file.write_text(dom.ast_json, encoding=\"utf-8\")\n        print(f\"Semantics saved to: {js_semantics_file}\")\n    else:\n        print(\"File does not exist!\")\n\n\ndef document_reorg(root_folder: Path | str) -&gt; None:\n    \"\"\"\n    iterates through a root folder recursively and analyzes the semantics of each Markdown document.\n    generate a json file containing the semantical summary of each document \n    output in the same folder as the original markdown file.capitalize\n    \"\"\"\n    root = Path(root_folder) if isinstance(root_folder, str) else root_folder\n    for file in root.rglob(\"*.md\"):\n        dom = DOM(file)\n        dom.setup()  # Load the Markdown content and convert it to JSON AST\n        ast_json_file = file.parent / (str(file.stem) + \"_ast.json\")\n        if not ast_json_file.exists() and dom.ast_json:\n            ast_json_file.write_text(dom.ast_json, encoding=\"utf-8\")\n            print(f\"Processing file: {file}\")\n        else:\n            print(f\"File already processed or no AST JSON available: {file}\")\n\n# document_reorg(Path(\"../res/md.mid.hrsl.test\"))\n# document_reorg(Path(\"/v/data/documents-semantics/.md\"))\n# document_reorg(Path(\"../res/SN024002\"))\n# document_reorg(Path(\"../res/test_batch_async\"))\n# document_reorg(Path(\"/v/data/documents-semantics/.md.hrsl\"))\n# document_reorg(Path(\"../res/siasun_md_sample_hrsl\"))\n\n\nasync def analyze_one_document_async(md_file: Path, semaphore: asyncio.Semaphore) -&gt; DOM:\n    \"\"\"\n    Asynchronously analyzes the semantics of a Markdown document.\n    Returns a DOM object containing the semantical summary of the document.\n    \"\"\"\n    try:\n        async with semaphore:  # Limit concurrent access to the semaphore\n            print(f\"Analyzing document: {md_file}\")\n            dom = DOM(md_file, client=chat_client)\n            dom.setup()  # Load the Markdown content and convert it to JSON AST\n            if dom.semantics_json:\n                print(f\"Document already analyzed: {md_file.stem}\")\n                return dom\n\n            await dom.textualize()  # Summarize the document\n            if dom.file_path:\n                ast_json_file = md_file.parent / (str(md_file.stem) + \"_semantics.json\")\n                ast_json_file.write_text(dom.ast_json, encoding=\"utf-8\")  # type: ignore\n                print(f\"Finished analyzing document: {md_file.stem}\")\n    except asyncio.CancelledError:\n        print(f\"Analysis cancelled for document: {md_file}\")\n        raise\n    return dom\n\n\ndef check_one_document(md_file: Path) -&gt; DOM | None:\n    \"\"\"\n    Asynchronously analyzes the semantics of a Markdown document.\n    Returns a DOM object containing the semantical summary of the document.\n    \"\"\"\n    print(f\"Checking document: {md_file}\")\n    dom = DOM(md_file, client=chat_client)\n    dom.setup()  # Load the Markdown content and convert it to JSON AST\n    if dom.semantics_json:\n        print(f\"Document already analyzed: {md_file.stem}\")\n        return None\n    else:\n        return dom\n\n\nimport tqdm\n\nasync def document_semantics_analysis(root_folder: Path) -&gt; None:\n    \"\"\"\n    iterates through a root folder recursively and analyzes the semantics of each Markdown document.\n    generate a json file containing the semantical summary of each document \n    output in the same folder as the original markdown file.capitalize\n    \"\"\"\n    \n    semaphore = asyncio.Semaphore(8)  # Limit the number of concurrent tasks\n    # Iterate through all Markdown files in the root folder recursively\n    # and create a task for each file to process it asynchronously\n    # files = list(root_folder.rglob(\"*.md\"))\n    # to_do = [analyze_one_document_async(file, semaphore) for file in files]\n\n    doms_to_analyze = [check_one_document(file) for file in root_folder.rglob(\"*.md\")]\n    to_do = [analyze_one_document_async(dom.file_path, semaphore) for dom in doms_to_analyze if dom is not None]  # type: ignore\n    to_do_iter = asyncio.as_completed(to_do)  # Create an iterator for the tasks\n    to_do_iter = tqdm.tqdm(to_do_iter, total=len(to_do), desc=\"Processing files\", unit=\"file\")\n    for coro in to_do_iter:\n        # Wait for each task to complete and get the result\n        try:\n            dom = await coro  # Await the completion of the task\n        except Exception as e:\n            print(f\"Error processing file: {e}\")\n            continue\n        print(f\"Processed file: {dom.file_path} with title: {dom.title}\")\n\n# Run the document semantics analysis\n# await document_semantics_analysis(Path(\"../res/SX023001《SIASUN Industrial Robotics》-A.1\"))\nawait document_semantics_analysis(Path(\"../res/md.mid.hrsl.test\"))\n# await document_semantics_analysis(Path(\"/v/data/documents-semantics/.md.mid.hrsl.test\"))\n\n# await document_semantics_analysis(Path(\"../res/test_batch_async\"))\n# await document_semantics_analysis(Path(\"../res/siasun_md_sample_hrsl\"))\n# await document_semantics_analysis(Path(\"../res/md.hrsl\"))\n# await document_semantics_analysis(Path(\"/v/data/documents-semantics/.md.hrsl\"))\n# await document_semantics_analysis(Path(\"/v/data/documents-semantics/.md.hrsl\"))\n# await document_semantics_analysis(Path(\"../res/SN024002\"))\n# await document_semantics_analysis(Path(\"/v/data/documents-semantics/.md.hrsl/05 技术规格\"))\n# await document_semantics_analysis(Path(\"/v/data/documents-semantics/.md.hrsl/06 产品手册\"))\n# await document_semantics_analysis(Path(\"/v/data/documents-semantics/.md.hrsl/06 产品样册\"))\n# await document_semantics_analysis(Path(\"/v/data/documents-semantics/.md.hrsl/08 检测报告与认证证书\"))\n\nProcessing files: 0file [00:00, ?file/s]Processing files: 0file [00:00, ?file/s]",
    "crumbs": [
      "core.dom"
    ]
  },
  {
    "objectID": "01.core.dom.html#asyncio-interface-of-processing-many-markdown-files",
    "href": "01.core.dom.html#asyncio-interface-of-processing-many-markdown-files",
    "title": "core.dom",
    "section": "asyncio interface of processing many markdown files",
    "text": "asyncio interface of processing many markdown files\n\nasync def process_one(file: Path) -&gt; None:\n    \"\"\"\n    Processes a single Markdown file and generates its semantics analysis.\n    \"\"\"\n    print(f\"Processing file started: {file}\")\n    dom = DOM(file, client=chat_client)\n    dom.setup()\n    ast_json_file = file.parent / (str(file.stem) + \"_ast.json\")\n    semantics_json_file = file.parent / (str(file.stem) + \"_semantics.json\")\n    ast_json_file.write_text(dom.ast_json, encoding=\"utf-8\")\n    await dom.textualize()\n    semantics_json_file.write_text(dom.ast_json, encoding=\"utf-8\")\n    print(f\"Semantics analysis completed for {file}. Results saved to {semantics_json_file}\")\n\n\nasync def supervisor(root_folder: Path) -&gt; int:\n    \"\"\"\n    Supervises the processing of Markdown files in a root folder.\n    \"\"\"\n\n    tasks = []\n    for file in root_folder.rglob(\"*.md\"):\n        print(f\"Processing file started: {file}\")\n        tasks.append(process_one(file))\n    \n    res = await asyncio.gather(*tasks)\n\n    return len(res)\n\n\ndef process_many(root_folder: Path) -&gt; None:\n    \"\"\"\n    Processes all Markdown files in a root folder recursively and generates their semantics analysis.\n    \"\"\"\n    \n    return asyncio.run(supervisor(root_folder))\n\nprocess_many(Path(\"../res/test_batch\"))",
    "crumbs": [
      "core.dom"
    ]
  },
  {
    "objectID": "01.core.dom.html#section-class-recursive-document-structure",
    "href": "01.core.dom.html#section-class-recursive-document-structure",
    "title": "core.dom",
    "section": "Section Class: Recursive Document Structure",
    "text": "Section Class: Recursive Document Structure\n\n\nSection\n\n Section (summary:Optional[str]=None, paragraphs:Optional[List[str]]=None,\n          figures:Optional[List[__main__.Figure]]=None,\n          tables:Optional[List[__main__.Table]]=None,\n          subsections:Optional[List[dict]]=None)\n\n*Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\nA base class for creating Pydantic models.\nAttributes: class_vars: The names of the class variables defined on the model. private_attributes: Metadata about the private attributes of the model. signature: The synthesized __init__ [Signature][inspect.Signature] of the model.\n__pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n__pydantic_core_schema__: The core schema of the model.\n__pydantic_custom_init__: Whether the model has a custom `__init__` function.\n__pydantic_decorators__: Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n__pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n__pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n__pydantic_post_init__: The name of the post-init method for the model, if defined.\n__pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n__pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n__pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n__pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n__pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n__pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n    is set to `'allow'`.\n__pydantic_fields_set__: The names of fields explicitly set during instantiation.\n__pydantic_private__: Values of private attributes set on the model instance.*",
    "crumbs": [
      "core.dom"
    ]
  },
  {
    "objectID": "01.parsing.ms_office.markitdown.html",
    "href": "01.parsing.ms_office.markitdown.html",
    "title": "parsing.ms_office.markitdown",
    "section": "",
    "text": "convert_office_to_md (root_folder:pathlib.Path|str,\n                       bOverwrite:bool=False, bUsePandas:bool=True,\n                       bUsePandoc:bool=False)\n\nRecursively convert all .pptx, .ppt, .docx, and .doc files under root_folder (and subfolders) to PDF files in the same folder as the original. For .xls and .xlsx files, convert to markdown (.md) files in the same folder. Requires LibreOffice (soffice) installed for Office document conversion. Requires pandas for Excel to markdown.\n\n\n\n\n\n extract_base64_images (markdown_file_path, image_output_folder='.')\n\n*Extracts base64 embedded images from a Markdown file, saves them to a folder, and replaces the base64 strings with relative paths to the new image files.\nArgs: markdown_file_path (str): Path to the input Markdown file. image_output_folder (str): Name of the folder to save extracted images. This folder will be created relative to the Markdown file’s directory if it doesn’t exist.*\n\n\n\n\n\n extract_md_base64_images_win (markdown_file_path,\n                               image_output_folder='.')\n\n*Extracts base64 embedded images from a Markdown file, saves them to a folder, and replaces the base64 strings with relative paths to the new image files. This version is tailored for Windows environments, ensuring compatibility with Windows file paths and handling of WMF/EMF images using ImageMagick ‘magick’ command.\nArgs: markdown_file_path (str): Path to the input Markdown file. image_output_folder (str): Name of the folder to save extracted images. This folder will be created relative to the Markdown file’s directory if it doesn’t exist.*\n\n\n\n\n\n extract_md_html_images_win (markdown_file_path)\n\n*Extracts base64 embedded images from a Markdown file, saves them to a folder, and replaces the base64 strings with relative paths to the new image files. This version is tailored for Windows environments, ensuring compatibility with Windows file paths and handling of WMF/EMF images using ImageMagick ‘magick’ command.\nArgs: markdown_file_path (str): Path to the input Markdown file. image_output_folder (str): Name of the folder to save extracted images. This folder will be created relative to the Markdown file’s directory if it doesn’t exist.*\n\n# --- How to use it ---\nif False:\n    # Create a dummy Markdown file for testing\n    dummy_md_content = \"\"\"\n# My Document\n\nThis is some text.\n\nHere is an image: ![A red dot](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==)\n\nSome more text.\n\nAnd another one: ![A blue square](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAFAAUDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAb/xAAgEAACAQMEAwAAAAAAAAAAAAABAgADBBESBSFBUSKR/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AIXVAvLBYy2PSkKOwz0A9YgA//Z)\n\nThis one is tricky with potential newlines in base64:\n![With Newlines](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\n)\n\nEnd of document.\n    \"\"\"\n    test_md_file = \"test_document.md\"\n    with open(test_md_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(dummy_md_content)\n    print(f\"Created dummy Markdown file: {test_md_file}\")\n\n    # Specify the path to your Markdown file\n    markdown_file = test_md_file  # Or \"your_actual_file.md\"\n    # Specify the folder (relative to the MD file) where images will be saved\n    image_folder = \"md_images\"\n\n    extract_base64_images(markdown_file, image_folder)\n\n    # --- Optional: Clean up dummy files and folder after testing ---\n    print(\"\\nCleaning up dummy files...\")\n    if os.path.exists(os.path.join(os.path.dirname(test_md_file), image_folder)):\n        for img_file in os.listdir(os.path.join(os.path.dirname(test_md_file), image_folder)):\n            os.remove(os.path.join(os.path.dirname(test_md_file), image_folder, img_file))\n        os.rmdir(os.path.join(os.path.dirname(test_md_file), image_folder))\n    if os.path.exists(test_md_file):\n        os.remove(test_md_file)\n    print(\"Cleanup complete.\")\n\n\n\n\n\n\n convert_html_wmf_emf_image_from_md (root_folder)\n\nRecursively convert all .md files under root_folder (and subfolders) and extract all base64 images in them into a separate folder and replace the base64 image references in the markdown files with the path to the extracted image.\n\n\n\n\n\n extract_base64_from_md (root_folder)\n\nRecursively convert all .md files under root_folder (and subfolders) and extract all base64 images in them into a separate folder and replace the base64 image references in the markdown files with the path to the extracted image.\n\n# extract_base64_from_md(r'D:/E/downloads/新型机器人智能问答系统数据源-mid/md')\n\n\n\n\n\n\n copy_md_files (src_md_root:pathlib.Path, dst_md_root:pathlib.Path,\n                bOverwrite:bool=True)\n\nRecursively copy all .md files under src_md_folder (higher quality of original office converted md by MID) (and subfolders) to dst_md_folder (low quality of original pdf converted md by gemini 2.5 pro exp).\n\nif False:\n    copy_md_files(Path('/v/data/新型机器人智能问答系统数据源-mid/.md.pandoc.raw.images'), Path('/v/data/新型机器人智能问答系统数据源-md/.md.pandoc.hrsl'))\n\n\n\n\n\n\n convert_all_to_markdown_with_llm (root_folder:str|pathlib.Path,\n                                   mid:markitdown._markitdown.MarkItDown)\n\nRecursively convert all .pdf files under root_folder (and subfolders) to markdown (.md) files in the same folder using marker-pdf’s ‘marker’ command with 4 workers.\n\n\n\n\n\n convert_pdf_to_markdown_pdf2text (root_folder:str|pathlib.Path)\n\nRecursively convert all .pdf files under root_folder (and subfolders) to markdown (.md) files in the same folder using marker-pdf’s ‘marker’ command with 4 workers.",
    "crumbs": [
      "parsing.ms_office.markitdown"
    ]
  },
  {
    "objectID": "01.parsing.ms_office.markitdown.html#install-dependencies",
    "href": "01.parsing.ms_office.markitdown.html#install-dependencies",
    "title": "parsing.ms_office.markitdown",
    "section": "",
    "text": "convert_office_to_md (root_folder:pathlib.Path|str,\n                       bOverwrite:bool=False, bUsePandas:bool=True,\n                       bUsePandoc:bool=False)\n\nRecursively convert all .pptx, .ppt, .docx, and .doc files under root_folder (and subfolders) to PDF files in the same folder as the original. For .xls and .xlsx files, convert to markdown (.md) files in the same folder. Requires LibreOffice (soffice) installed for Office document conversion. Requires pandas for Excel to markdown.\n\n\n\n\n\n extract_base64_images (markdown_file_path, image_output_folder='.')\n\n*Extracts base64 embedded images from a Markdown file, saves them to a folder, and replaces the base64 strings with relative paths to the new image files.\nArgs: markdown_file_path (str): Path to the input Markdown file. image_output_folder (str): Name of the folder to save extracted images. This folder will be created relative to the Markdown file’s directory if it doesn’t exist.*\n\n\n\n\n\n extract_md_base64_images_win (markdown_file_path,\n                               image_output_folder='.')\n\n*Extracts base64 embedded images from a Markdown file, saves them to a folder, and replaces the base64 strings with relative paths to the new image files. This version is tailored for Windows environments, ensuring compatibility with Windows file paths and handling of WMF/EMF images using ImageMagick ‘magick’ command.\nArgs: markdown_file_path (str): Path to the input Markdown file. image_output_folder (str): Name of the folder to save extracted images. This folder will be created relative to the Markdown file’s directory if it doesn’t exist.*\n\n\n\n\n\n extract_md_html_images_win (markdown_file_path)\n\n*Extracts base64 embedded images from a Markdown file, saves them to a folder, and replaces the base64 strings with relative paths to the new image files. This version is tailored for Windows environments, ensuring compatibility with Windows file paths and handling of WMF/EMF images using ImageMagick ‘magick’ command.\nArgs: markdown_file_path (str): Path to the input Markdown file. image_output_folder (str): Name of the folder to save extracted images. This folder will be created relative to the Markdown file’s directory if it doesn’t exist.*\n\n# --- How to use it ---\nif False:\n    # Create a dummy Markdown file for testing\n    dummy_md_content = \"\"\"\n# My Document\n\nThis is some text.\n\nHere is an image: ![A red dot](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==)\n\nSome more text.\n\nAnd another one: ![A blue square](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAFAAUDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAb/xAAgEAACAQMEAwAAAAAAAAAAAAABAgADBBESBSFBUSKR/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AIXVAvLBYy2PSkKOwz0A9YgA//Z)\n\nThis one is tricky with potential newlines in base64:\n![With Newlines](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\n)\n\nEnd of document.\n    \"\"\"\n    test_md_file = \"test_document.md\"\n    with open(test_md_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(dummy_md_content)\n    print(f\"Created dummy Markdown file: {test_md_file}\")\n\n    # Specify the path to your Markdown file\n    markdown_file = test_md_file  # Or \"your_actual_file.md\"\n    # Specify the folder (relative to the MD file) where images will be saved\n    image_folder = \"md_images\"\n\n    extract_base64_images(markdown_file, image_folder)\n\n    # --- Optional: Clean up dummy files and folder after testing ---\n    print(\"\\nCleaning up dummy files...\")\n    if os.path.exists(os.path.join(os.path.dirname(test_md_file), image_folder)):\n        for img_file in os.listdir(os.path.join(os.path.dirname(test_md_file), image_folder)):\n            os.remove(os.path.join(os.path.dirname(test_md_file), image_folder, img_file))\n        os.rmdir(os.path.join(os.path.dirname(test_md_file), image_folder))\n    if os.path.exists(test_md_file):\n        os.remove(test_md_file)\n    print(\"Cleanup complete.\")\n\n\n\n\n\n\n convert_html_wmf_emf_image_from_md (root_folder)\n\nRecursively convert all .md files under root_folder (and subfolders) and extract all base64 images in them into a separate folder and replace the base64 image references in the markdown files with the path to the extracted image.\n\n\n\n\n\n extract_base64_from_md (root_folder)\n\nRecursively convert all .md files under root_folder (and subfolders) and extract all base64 images in them into a separate folder and replace the base64 image references in the markdown files with the path to the extracted image.\n\n# extract_base64_from_md(r'D:/E/downloads/新型机器人智能问答系统数据源-mid/md')\n\n\n\n\n\n\n copy_md_files (src_md_root:pathlib.Path, dst_md_root:pathlib.Path,\n                bOverwrite:bool=True)\n\nRecursively copy all .md files under src_md_folder (higher quality of original office converted md by MID) (and subfolders) to dst_md_folder (low quality of original pdf converted md by gemini 2.5 pro exp).\n\nif False:\n    copy_md_files(Path('/v/data/新型机器人智能问答系统数据源-mid/.md.pandoc.raw.images'), Path('/v/data/新型机器人智能问答系统数据源-md/.md.pandoc.hrsl'))\n\n\n\n\n\n\n convert_all_to_markdown_with_llm (root_folder:str|pathlib.Path,\n                                   mid:markitdown._markitdown.MarkItDown)\n\nRecursively convert all .pdf files under root_folder (and subfolders) to markdown (.md) files in the same folder using marker-pdf’s ‘marker’ command with 4 workers.\n\n\n\n\n\n convert_pdf_to_markdown_pdf2text (root_folder:str|pathlib.Path)\n\nRecursively convert all .pdf files under root_folder (and subfolders) to markdown (.md) files in the same folder using marker-pdf’s ‘marker’ command with 4 workers.",
    "crumbs": [
      "parsing.ms_office.markitdown"
    ]
  },
  {
    "objectID": "01.parsing.ms_office.marker.html",
    "href": "01.parsing.ms_office.marker.html",
    "title": "parsing.ms_office.marker",
    "section": "",
    "text": "convert_office_to_pdf (root_folder)\n\nRecursively convert all .pptx, .ppt, .docx, and .doc files under root_folder (and subfolders) to PDF files in the same folder as the original. For .xls and .xlsx files, convert to markdown (.md) files in the same folder. Requires LibreOffice (soffice) installed for Office document conversion. Requires pandas for Excel to markdown.\n\n\n\n\n\n convert_excel_to_markdown (file_path)\n\nConvert an Excel file to a markdown file.\n\n# print(f'--gemini_api_key={GEMINI_KEY}')\n\n# print(f'--openai_api_key={OPENROUTER_API_KEY}')\n# print(f'--openai_model={OPENROUTER_MODEL}')\n# print(f'--openai_base_url={OPENROUTER_API_URL}')\n\n\n\n\n\n\n convert_pdf_to_markdown_with_marker (root_folder)\n\nRecursively convert all .pdf files under root_folder (and subfolders) to markdown (.md) files in the same folder using marker-pdf’s ‘marker’ command with 4 workers.\n\n\n\n\n\n convert_excel_to_markdown_with_marker (root_folder)\n\nRecursively convert all .excel files under root_folder (and subfolders) to markdown (.md) files in the same folder using marker-pdf’s ‘marker’ command with 4 workers.",
    "crumbs": [
      "parsing.ms_office.marker"
    ]
  },
  {
    "objectID": "01.parsing.ms_office.marker.html#install-dependencies",
    "href": "01.parsing.ms_office.marker.html#install-dependencies",
    "title": "parsing.ms_office.marker",
    "section": "",
    "text": "convert_office_to_pdf (root_folder)\n\nRecursively convert all .pptx, .ppt, .docx, and .doc files under root_folder (and subfolders) to PDF files in the same folder as the original. For .xls and .xlsx files, convert to markdown (.md) files in the same folder. Requires LibreOffice (soffice) installed for Office document conversion. Requires pandas for Excel to markdown.\n\n\n\n\n\n convert_excel_to_markdown (file_path)\n\nConvert an Excel file to a markdown file.\n\n# print(f'--gemini_api_key={GEMINI_KEY}')\n\n# print(f'--openai_api_key={OPENROUTER_API_KEY}')\n# print(f'--openai_model={OPENROUTER_MODEL}')\n# print(f'--openai_base_url={OPENROUTER_API_URL}')\n\n\n\n\n\n\n convert_pdf_to_markdown_with_marker (root_folder)\n\nRecursively convert all .pdf files under root_folder (and subfolders) to markdown (.md) files in the same folder using marker-pdf’s ‘marker’ command with 4 workers.\n\n\n\n\n\n convert_excel_to_markdown_with_marker (root_folder)\n\nRecursively convert all .excel files under root_folder (and subfolders) to markdown (.md) files in the same folder using marker-pdf’s ‘marker’ command with 4 workers.",
    "crumbs": [
      "parsing.ms_office.marker"
    ]
  }
]