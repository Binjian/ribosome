---
output-file: 01.core.dom.html
title: core.dom

---


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->


## Base Element Class

---

### Element

>      Element (summary:Optional[str]=None)

*Represents a DOM element with a tag, attributes, and children.*


## Figure Class with Base64 Validation

---

### Figure

>      Figure (summary:Optional[str]=None, rawdata:str)

*Represents a figure element in the document.*


## Table Structure: Cell, Column, Row, Table

---

### Table

>      Table (summary:Optional[str]=None, rows:List[__main__.Row])

*Represents a table element in the document.*


---

### Row

>      Row (cols:List[__main__.Column])

*Represents a table row in the document.*


---

### Column

>      Column (cells:List[__main__.Cell])

*Represents a table column in the document.*


---

### Cell

>      Cell (c:str)

*Represents a table cell in the document.*


---

### get_text_summary_response

>      get_text_summary_response (content:str, model:str='gemma3-27b',
>                                 role:str='user', lang:str='zh')

*Returns a ChatResponse from the chat model with a summary prompt for the given content.*


---

### get_image_summary_response

>      get_image_summary_response (image_link:str|pathlib.Path,
>                                  model:str='gemma3:27b', role:str='user',
>                                  lang:str='zh')

*Returns a ChatResponse from the chat model with a summary prompt for the given image.*


---

### get_image_summary_response_async

>      get_image_summary_response_async (client:ollama._client.AsyncClient,
>                                        image_link:str|pathlib.Path,
>                                        model:str='gemma3:27b',
>                                        role:str='user', lang:str='zh')

*Returns a ChatResponse from the chat model with a summary prompt for the given image.*


---

### get_text_summary_response_async

>      get_text_summary_response_async (client:ollama._client.AsyncClient,
>                                       content:str, model:str='gemma3-27b',
>                                       role:str='user', lang:str='zh')

*Returns a ChatResponse from the chat model with a summary prompt for the given content.*


::: {#28596903 .cell}
``` {.python .cell-code}
imagepath = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SN024002/img/img_13.png'
# imagepath = Path(os.getcwd()).parent / 'res/siasun_md_sample/SN024002/img/img_13.png'
# imagepath = Path(os.getcwd()).parent / 'siasun_md_sample_hrsl/SN024002/img/img_11.png'
# imagepath = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SX322002/img/img_13.png'
image_link = str(imagepath)
image_link
display(Markdown(f"![image]({image_link})"))
```
:::


::: {#400bfd40 .cell}
``` {.python .cell-code}
# res = re.match(image_link_pattern, 'http://baidu.com/?home/img/small.png')
res = re.match(image_link_pattern, 'img/small.png')
# res = re.match(image_link_pattern, image_link)
# in case of match, print the matched string
if res:
    print(f"Matched image link: {res.group(0)}")
else:
    print(res)
```
:::


::: {#5315073c .cell}
``` {.python .cell-code}
if False: 
    # response = await get_image_summary_response_async(image_link, model="gemma3:27b", role="user", lang='zh')
    response = await get_image_summary_response_async(chat_client, image_link, model="gemma3:27b", role="user", lang='zh')
    assert isinstance(response.message.content, str), "Response content should be a string"
    md_text = markdown.markdown(response.message.content)
    Markdown(md_text)
    # print(md_text)
    # print(response.content)
    # response_txt = await get_text_summary_response_async(md_text,model="gemma3:27b", role="user", lang='zh')
    # md_text = markdown.markdown(response_txt.message.content)
    # Markdown(md_text)
```
:::


::: {#37ba93d5 .cell}
``` {.python .cell-code}
if False: 
    # response = await get_image_summary_response_async(image_link, model="gemma3:27b", role="user", lang='zh')
    response = await get_image_summary_response_async(chat_client, image_link, model="gemma3:27b", role="user", lang='zh')
    assert isinstance(response.message.content, str), "Response content should be a string"
    md_text = markdown.markdown(response.message.content)
    Markdown(md_text)
    # print(md_text)
    # print(response.content)
    # response_txt = await get_text_summary_response_async(md_text,model="gemma3:27b", role="user", lang='zh')
    # md_text = markdown.markdown(response_txt.message.content)
    # Markdown(md_text)
```
:::


## DOM Class with pypandoc Integration

---

### DOM

>      DOM (md_file_path:pathlib.Path,
>           llm_client:Optional[ollama._client.AsyncClient]=None,
>           db_client:Optional[chromadb.api.ClientAPI]=None,
>           raw_markdown:Optional[str]=None, raw_json:Optional[str]=None,
>           ast_json:Optional[str]=None, semantics_json:Optional[str]=None,
>           embed_json:Optional[str]=None,
>           file_path:Optional[pathlib.Path]=None,
>           root_path:pathlib.Path=<factory>, table_count:int=0,
>           section_count:int=0, section_level:list=<factory>, title:str='')

*Usage docs: https://docs.pydantic.dev/2.10/concepts/models/

A base class for creating Pydantic models.

Attributes:
    __class_vars__: The names of the class variables defined on the model.
    __private_attributes__: Metadata about the private attributes of the model.
    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*


::: {#e756760d .cell}
``` {.python .cell-code}
if False:
    # md_file = Path('/d/devel/rag/ribosome/res/md.hrsl/01 设计标准/SX047001新松机器人产品识别设计标准A-1/SX047001新松机器人产品识别设计标准A-1.md') 
    # md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SR02400401/SR02400401《 SIASUN SR210A-210-2.65 Specifications-CE》A-0.md'
    # md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SX322002/SX322002.md'
    # md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SR024011/SR024011.md'
    md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample_hrsl/SN024002/SN024002.md'
    # md_file = Path(os.getcwd()).parent / 'res/siasun_md_sample/SN024002/SN024002.md'
    print(f"Using file: {md_file}")
    print(f"File exists: {md_file.exists()}")
    
    if md_file.exists():
        dom = DOM(md_file, client=chat_client)
        dom.setup()
        print(f"Raw JSON length: {len(dom.raw_json) if dom.raw_json else 0}")
        print(f"AST JSON length: {len(dom.ast_json) if dom.ast_json else 0}")
        
        js_sections_file = md_file.parent / (str(md_file.stem) + "_presentation.json")
        print(f"Saving to: {js_sections_file}")
        # Write the JSON representation of the AST to the file
        js_sections_file.write_text(dom.ast_json, encoding="utf-8")
        
        # Test textualize functionality
        print("Starting textualization...")
        await dom.textualize()
        
        js_semantics_file = md_file.parent / (str(md_file.stem) + "_semantics.json")
        js_semantics_file.write_text(dom.ast_json, encoding="utf-8")
        print(f"Semantics saved to: {js_semantics_file}")
    else:
        print("File does not exist!")
```
:::


::: {#24c93d3e .cell}
``` {.python .cell-code}
def document_reorg(root_folder: Path | str) -> None:
    """
    iterates through a root folder recursively and analyzes the semantics of each Markdown document.
    generate a json file containing the semantical summary of each document 
    output in the same folder as the original markdown file.capitalize
    """
    root = Path(root_folder) if isinstance(root_folder, str) else root_folder
    for file in root.rglob("*.md"):
        dom = DOM(file)
        dom.setup()  # Load the Markdown content and convert it to JSON AST
        ast_json_file = file.parent / (str(file.stem) + "_ast.json")
        if not ast_json_file.exists() and dom.ast_json:
            ast_json_file.write_text(dom.ast_json, encoding="utf-8")
            print(f"Processing file: {file}")
        else:
            print(f"File already processed or no AST JSON available: {file}")

# document_reorg(Path("../res/md.mid.hrsl.test"))
# document_reorg(Path("/v/data/documents-semantics/.md"))
# document_reorg(Path("../res/SN024002"))
# document_reorg(Path("../res/test_batch_async"))
# document_reorg(Path("/v/data/documents-semantics/.md.hrsl"))
# document_reorg(Path("../res/siasun_md_sample_hrsl"))
```
:::


::: {#8e3e37aa .cell}
``` {.python .cell-code}
async def analyze_one_document_async(md_file: Path, semaphore: asyncio.Semaphore) -> DOM:
    """
    Asynchronously analyzes the semantics of a Markdown document.
    Returns a DOM object containing the semantical summary of the document.
    """
    try:
        async with semaphore:  # Limit concurrent access to the semaphore
            print(f"Analyzing document: {md_file}")
            dom = DOM(md_file, client=chat_client)
            dom.setup()  # Load the Markdown content and convert it to JSON AST
            if dom.semantics_json:
                print(f"Document already analyzed: {md_file.stem}")
                return dom

            await dom.textualize()  # Summarize the document
            if dom.file_path:
                ast_json_file = md_file.parent / (str(md_file.stem) + "_semantics.json")
                ast_json_file.write_text(dom.ast_json, encoding="utf-8")  # type: ignore
                print(f"Finished analyzing document: {md_file.stem}")
    except asyncio.CancelledError:
        print(f"Analysis cancelled for document: {md_file}")
        raise
    return dom
```
:::


::: {#43593949 .cell}
``` {.python .cell-code}
def check_one_document(md_file: Path) -> DOM | None:
    """
    Asynchronously analyzes the semantics of a Markdown document.
    Returns a DOM object containing the semantical summary of the document.
    """
    print(f"Checking document: {md_file}")
    dom = DOM(md_file, client=chat_client)
    dom.setup()  # Load the Markdown content and convert it to JSON AST
    if dom.semantics_json:
        print(f"Document already analyzed: {md_file.stem}")
        return None
    else:
        return dom
```
:::


::: {#5f7a1ffa .cell}
``` {.python .cell-code}
import tqdm

async def document_semantics_analysis(root_folder: Path) -> None:
    """
    iterates through a root folder recursively and analyzes the semantics of each Markdown document.
    generate a json file containing the semantical summary of each document 
    output in the same folder as the original markdown file.capitalize
    """
    
    semaphore = asyncio.Semaphore(8)  # Limit the number of concurrent tasks
    # Iterate through all Markdown files in the root folder recursively
    # and create a task for each file to process it asynchronously
    # files = list(root_folder.rglob("*.md"))
    # to_do = [analyze_one_document_async(file, semaphore) for file in files]

    doms_to_analyze = [check_one_document(file) for file in root_folder.rglob("*.md")]
    to_do = [analyze_one_document_async(dom.file_path, semaphore) for dom in doms_to_analyze if dom is not None]  # type: ignore
    to_do_iter = asyncio.as_completed(to_do)  # Create an iterator for the tasks
    to_do_iter = tqdm.tqdm(to_do_iter, total=len(to_do), desc="Processing files", unit="file")
    for coro in to_do_iter:
        # Wait for each task to complete and get the result
        try:
            dom = await coro  # Await the completion of the task
        except Exception as e:
            print(f"Error processing file: {e}")
            continue
        print(f"Processed file: {dom.file_path} with title: {dom.title}")

# Run the document semantics analysis
# await document_semantics_analysis(Path("../res/SX023001《SIASUN Industrial Robotics》-A.1"))
await document_semantics_analysis(Path("../res/md.mid.hrsl.test"))
# await document_semantics_analysis(Path("/v/data/documents-semantics/.md.mid.hrsl.test"))

# await document_semantics_analysis(Path("../res/test_batch_async"))
# await document_semantics_analysis(Path("../res/siasun_md_sample_hrsl"))
# await document_semantics_analysis(Path("../res/md.hrsl"))
# await document_semantics_analysis(Path("/v/data/documents-semantics/.md.hrsl"))
# await document_semantics_analysis(Path("/v/data/documents-semantics/.md.hrsl"))
# await document_semantics_analysis(Path("../res/SN024002"))
# await document_semantics_analysis(Path("/v/data/documents-semantics/.md.hrsl/05 技术规格"))
# await document_semantics_analysis(Path("/v/data/documents-semantics/.md.hrsl/06 产品手册"))
# await document_semantics_analysis(Path("/v/data/documents-semantics/.md.hrsl/06 产品样册"))
# await document_semantics_analysis(Path("/v/data/documents-semantics/.md.hrsl/08 检测报告与认证证书"))
```

::: {.cell-output .cell-output-stderr}
```
Processing files: 0file [00:00, ?file/s]Processing files: 0file [00:00, ?file/s]
```
:::
:::


## asyncio interface of processing many markdown files

::: {#489c872d .cell}
``` {.python .cell-code}
async def process_one(file: Path) -> None:
    """
    Processes a single Markdown file and generates its semantics analysis.
    """
    print(f"Processing file started: {file}")
    dom = DOM(file, client=chat_client)
    dom.setup()
    ast_json_file = file.parent / (str(file.stem) + "_ast.json")
    semantics_json_file = file.parent / (str(file.stem) + "_semantics.json")
    ast_json_file.write_text(dom.ast_json, encoding="utf-8")
    await dom.textualize()
    semantics_json_file.write_text(dom.ast_json, encoding="utf-8")
    print(f"Semantics analysis completed for {file}. Results saved to {semantics_json_file}")
```
:::


::: {#f39b5dc3 .cell}
``` {.python .cell-code}
async def supervisor(root_folder: Path) -> int:
    """
    Supervises the processing of Markdown files in a root folder.
    """

    tasks = []
    for file in root_folder.rglob("*.md"):
        print(f"Processing file started: {file}")
        tasks.append(process_one(file))
    
    res = await asyncio.gather(*tasks)

    return len(res)
```
:::


::: {#6cf4ea06 .cell}
``` {.python .cell-code}
def process_many(root_folder: Path) -> None:
    """
    Processes all Markdown files in a root folder recursively and generates their semantics analysis.
    """
    
    return asyncio.run(supervisor(root_folder))

process_many(Path("../res/test_batch"))
```
:::


## Section Class: Recursive Document Structure

---

### Section

>      Section (summary:Optional[str]=None, paragraphs:Optional[List[str]]=None,
>               figures:Optional[List[__main__.Figure]]=None,
>               tables:Optional[List[__main__.Table]]=None,
>               subsections:Optional[List[dict]]=None)

*Usage docs: https://docs.pydantic.dev/2.10/concepts/models/

A base class for creating Pydantic models.

Attributes:
    __class_vars__: The names of the class variables defined on the model.
    __private_attributes__: Metadata about the private attributes of the model.
    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.

    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
    __pydantic_core_schema__: The core schema of the model.
    __pydantic_custom_init__: Whether the model has a custom `__init__` function.
    __pydantic_decorators__: Metadata containing the decorators defined on the model.
        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
    __pydantic_post_init__: The name of the post-init method for the model, if defined.
    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
        is set to `'allow'`.
    __pydantic_fields_set__: The names of fields explicitly set during instantiation.
    __pydantic_private__: Values of private attributes set on the model instance.*


